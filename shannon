#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__author__ = 'Ã–nder Kartal'

import argparse
import io
import os
import sys

import pandas as pd

from shannonlib.core import divergence


def run_divergence(args):

    metadata = args.metadata
    chrom = args.sequence
    outfile = args.output
    query = None
    groupby = None

    if os.path.isfile(outfile) and not os.stat(outfile).st_size == 0:
        msg = "-- Stopped!\n-- Output file exists and is not empty."
        sys.exit(msg)

    meta = metadata.read()

    try:
        population = pd.read_csv(io.StringIO(meta), comment='#', header=0)
        _ = population['url']
        _ = population['label']
    except KeyError:
        try:
            population = pd.read_csv(io.StringIO(
                meta), comment='#', header=0, sep='\t')
            _ = population['url']
            _ = population['label']
        except KeyError:
            msg = ('-- Stopped!\n'
                   '-- Could not parse metadata.\n'
                   '-- 1. Ensure that fields are tab- or comma-separated\n'
                   '-- 2. Ensure that columns "url" and "label" are present')
            sys.exit(msg)

    if query is not None:
        population.query(query, inplace=True)

    if groupby is not None:
        metapopulation = population.groupby(groupby)
        for key, subpop in metapopulation:
            filename = groupname(by=groupby, name=key, fname=outfile)
            divergence(pop=subpop, chrom=chrom, filename=filename)
    else:
        print('processing sequence {} ...'.format(chrom))
        divergence(population, chrom=chrom, outfile=outfile,
                   chunksize=args.chunksize)

    return None


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    # main parser
    parser.prog = 'shannon'
    parser.description = 'Command-line interface to %(prog)s.'

    # cluster
    parser_cluster = subparsers.add_parser('cluster')

    # segment
    parser_segment = subparsers.add_parser('seg')

    # divergence
    parser_divergence = subparsers.add_parser('div')

    parser_divergence.set_defaults(func=run_divergence)
    parser_divergence.help = 'JS Divergence for each position.'
    parser_divergence.description = parser_divergence.help

    parser_divergence.add_argument(
        '-c',
        '--chunksize',
        metavar='INT',
        default=1e4,
        type=int,
        help='''
        Expected number of sites that are processed at the same time in memory.
        Higher numbers lead to faster but also more memory-hungry computations.
        (default: %(default)d)
        ''')

    parser_divergence.add_argument(
        '-m',
        '--metadata',
        metavar='FILE',
        type=argparse.FileType('r'),
        required=True,
        help='''
        Metadata for each genome position file. Lines starting with # are
        ignored and the first non-comment line must be the header. The headers
        "url" and "label" are required. Use a dash (-) as FILE if you pipe it
        from stdin.
        '''
    )
    parser_divergence.add_argument(
        '-o',
        '--output',
        metavar='FILE',
        required=True,
        help='Output filename'
    )
    parser_divergence.add_argument(
        '-s',
        '--sequence',
        metavar='ID',
        required=True,
        type=str,
        help='Sequence (chromosome/scaffold) in genome position file'
    )
    parser_divergence.add_argument(
        '--dtype',
        required=True,
        choices=['count', 'prob'],
        help='Type of data in genome position files'
    )
    parser_divergence.add_argument(
        '--dcols',
        metavar='INT',
        nargs='+',
        required=True,
        type=int,
        help='Data columns in genome position files'
    )
    parser_divergence.add_argument(
        '--dnames',
        metavar='STR',
        nargs='+',
        required=True,
        type=str,
        help='Names of data columns'
    )
# parser_divergence.add_argument('-q', '--query', metavar='"EXPRESSION"',
    # type=str,
    #                           help='''
    #                     Query to select a subsample. The expression has to be in
    #                     double quotes and must reference columns in the metadata
    #                     table (e.g. -q "tissue == 'leaf'", -q "age >= 32").
    #                     ''')

    # parser.add_argument('-g', '--groupby', metavar='STR', nargs='+', type=str,
    #                     help='''
    #                     The factor according to which the selected set is
    #                     partitioned; has to match column names in the input
    #                     metadata. One or more factors can be given, which
    #                     produces a file for each combination of factors.
    #                     ''')

    args = parser.parse_args()
    args.func(args)
