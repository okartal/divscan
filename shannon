#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__author__ = 'Ã–nder Kartal'

import argparse
import io
import os
import sys

import pandas as pd

from shannonlib.core import divergence


def run_divergence(args):

    metadata = args.metadata
    chrom = args.sequence
    outfile = args.output
    query = None
    groupby = None

    if os.path.isfile(outfile) and not os.stat(outfile).st_size == 0:
        msg = "-- Stopped!\n-- Output file exists and is not empty."
        sys.exit(msg)

    meta = metadata.read()

    try:
        population = pd.read_csv(io.StringIO(meta), comment='#', header=0)
        _ = population['url']
        _ = population['label']
    except KeyError:
        try:
            population = pd.read_csv(io.StringIO(meta), comment='#', header=0, sep='\t')
            _ = population['url']
            _ = population['label']
        except KeyError:
            msg = ('-- Stopped!\n'
                   '-- Could not parse metadata.\n'
                   '-- 1. Ensure that file is tab- or comma-separated\n'
                   '-- 2. Ensure that columns "url" and "label" are present')
            sys.exit(msg)

    if query is not None:
        population.query(query, inplace=True)

    if groupby is not None:
        metapopulation = population.groupby(groupby)
        for key, subpop in metapopulation:
            filename = groupname(by=groupby, name=key, fname=outfile)
            divergence(pop=subpop, chrom=chrom, filename=filename)
    else:
        filename = outfile
        divergence(pop=population, chrom=chrom, filename=filename)

    return None


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()

    # main parser
    parser.prog = 'shannon'
    parser.description = 'Command-line interface to %(prog)s.'

    # cluster
    parser_cluster = subparsers.add_parser('cluster')

    # segment
    parser_segment = subparsers.add_parser('seg')

    # divergence
    parser_divergence = subparsers.add_parser('div')
    parser_divergence.help = 'JS Divergence for each position.'
    parser_divergence.description = parser_divergence.help
    parser_divergence.set_defaults(func=run_divergence)

    parser_divergence.add_argument(
        '-s',
        '--sequence',
        metavar='ID',        
        required=True,
        type=str,
        help='''
        ID of query chromosome or scaffold from the genome position file.
        ''')

    parser_divergence.add_argument(
        '-m',
        '--metadata',
        metavar='FILE',        
        type=argparse.FileType('r'),
        required=True,
        help='''
        Metadata table with one row for each genome
        position file in the sample. Lines starting with  # are
        ignored. The first line without '#' is interpreted as the header.
        The columns "url" and "label" are required.
        ''')

    parser_divergence.add_argument(
        '-o',
        '--output',
        metavar='FILE',
        required=True,
        help='''
        Name of the output file. If the file exists and
        is not empty, execution will stop.
        ''')


# parser_divergence.add_argument('-q', '--query', metavar='"EXPRESSION"',
    # type=str,
    #                           help='''
    #                     Query to select a subsample. The expression has to be in
    #                     double quotes and must reference columns in the metadata
    #                     table (e.g. -q "tissue == 'leaf'", -q "age >= 32").
    #                     ''')

    # parser.add_argument('-g', '--groupby', metavar='STR', nargs='+', type=str,
    #                     help='''
    #                     The factor according to which the selected set is
    #                     partitioned; has to match column names in the input
    #                     metadata. One or more factors can be given, which
    #                     produces a file for each combination of factors.
    #                     ''')

    args = parser.parse_args()
    args.func(args)
